# -*- coding: utf-8 -*-
"""AutoEncoder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e9o7EsAGmvrvtHbzCs1lD0Z95evsuL0i
"""

import csv
import numpy as np
from sklearn.preprocessing import StandardScaler
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from keras.layers import Input, Dense
from keras.models import Model

def train_autoencoder():
    #Get and prep data
    file_names = ["index_flex_out.csv","middle_flex_out.csv","ring_flex_out.csv","pinky_flex_out.csv","thumb_flex_out.csv"]
    """while True:
        name = raw_input("Please input a file name to run t-SNE on (or \"quit\" to stop inputting): ")
        if name == "quit":
            break
        file_names.append(name)"""

    data = []
    for i in range(len(file_names)):
        with open(file_names[i]) as file:
            reader = list(csv.reader(file))
            data.append([])
            for j in range(len(reader)):
                data[i].append([])
                for k in range(len(reader[j])):
                    data[i][j].append(float(reader[j][k]))

    index_end = len(data[0])
    middle_end = len(data[1]) + index_end
    ring_end = len(data[2]) + middle_end
    pinky_end = len(data[3]) + ring_end

    formatted_data = np.asarray(data[0] + data[1] + data[2] + data[3] + data[4])

    # keep track of normalization factor
    normalization_factor = np.linalg.norm(formatted_data)#np.amax(formatted_data)
  
    # normalize data
    normalized_data = formatted_data / normalization_factor

    print(np.amax((normalized_data * normalization_factor) - formatted_data))

    #FOLLOWING MODIFIED FROM: https://blog.keras.io/building-autoencoders-in-keras.html
    # this is the size of our encoded representations
    encoding_dim = 2  # 2 dimensions to plot on X,Y chart

    # this is our input placeholder
    input_vec = Input(shape=(20,))

    # Hidden layer to help with condensing
    #encode_layer = Dense(10, activation='sigmoid')(input_vec)

    # "encoded" is the encoded representation of the input
    encoded = Dense(encoding_dim, activation=None)(input_vec)

    # Hidden layer to help with expanding
    #decode_layer = Dense(10, activation='sigmoid')(encoded)

    # "decoded" is the lossy reconstruction of the input
    decoded = Dense(20, activation=None)(encoded)

    # this model maps an input to its reconstruction
    autoencoder = Model(input_vec, decoded)

    # this model maps an input to its encoded representation
    encoder = Model(input_vec, encoded)

    # create a placeholder for an encoded (2-dimensional) input
    encoded_input = Input(shape=(encoding_dim,))
    # retrieve the last layer of the autoencoder model
    decoder_layer = autoencoder.layers[-1]
    # create the decoder model
    decoder = Model(encoded_input, decoder_layer(encoded_input))

    autoencoder.compile(optimizer='sgd', loss='mse')

    autoencoder.fit(normalized_data, normalized_data,
                epochs=300,
                batch_size=256,
                shuffle=False,
                validation_data=(normalized_data, normalized_data))
    
    encoded_pts = encoder.predict(normalized_data)

    plt.plot(encoded_pts[:index_end,0], encoded_pts[:index_end,1], 'ro',
        encoded_pts[index_end:middle_end,0], encoded_pts[index_end:middle_end,1], 'bo',
        encoded_pts[middle_end:ring_end,0], encoded_pts[middle_end:ring_end,1], 'go',
        encoded_pts[ring_end:pinky_end,0], encoded_pts[ring_end:pinky_end,1], 'co',
        encoded_pts[pinky_end:,0], encoded_pts[pinky_end:,1], 'mo'
        )
    
    red_patch = mpatches.Patch(color='red', label='index flexion')
    blue_patch = mpatches.Patch(color='blue', label='middle flexion')
    green_patch = mpatches.Patch(color='green', label='ring flexion')
    cyan_patch = mpatches.Patch(color='cyan', label='pinky flexion')
    magenta_patch = mpatches.Patch(color='magenta', label='thumb flexion')
    plt.title("Autoencoder")
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
    plt.legend(handles=[red_patch, blue_patch, green_patch, cyan_patch, magenta_patch])
    plt.show()

    decoded_pts = decoder.predict(encoded_pts)
    print(np.amax((normalization_factor * decoded_pts) - formatted_data))
    print(np.amax(decoded_pts - normalized_data))
    print(normalized_data)

train_autoencoder()